Repository of the project created during the Node.js for Beginners course of [#NodeBR] (https://erickwendel.teachable.com/p/node-js-para-iniciantes-nodebr)

- Course link: https://erickwendel.teachable.com/p/node-js-para-iniciantes-nodebr
- Documentation link generated by Swagger: https://ilso-api-herois.herokuapp.com/documentation
- API test coverage index link: https://ilso-api-herois.herokuapp.com/coverage/index.html

## Contents of the classes:

### Module 00 - Course Introduction

### Module 01 – Synchronization of Javascript functions

#### Lesson 02: In this module we saw about callbacks and promises

In this class it was the first "Boom" that hit my brain...
I've seen instructors in other courses using either the callback or the promise, but in none of them does the instructor delve into the concept of each one of them (perhaps to save time...).
But in this course I was able to really understand the concept of each of them and even convert a callback into a promise, manually or automatically

#### Class 03: EventEmitter

In this class we saw about a node library that has a high applicability. It can be used, for example, to generate logs, send notifications/alerts, trigger other functions, etc.

### Module 02 – List manipulation

#### Class 04 - Lists

In this class we saw about manipulation of lists (vectors):

- for / for in / for of
- array.map
- Array.filter
- Array.reduce

### Module 03 – Introduction of Automated Tests

#### Class 05 - Tests

An introduction to test-driven development with the Mocha library

### Module 04 – Node.js Beyond the Web - Creating Command Line Tools

#### Lesson 06 - CLI

We created a command line tool to simulate a CRUD with a database in a .json file

### Module 05 – Our multi-database project

#### Class 07 - Multi DB

Created Strategy design patterns for working with multi-banks, as follows:

1. We create the **ICrud** class. This class will be responsible for "interfacing" the strategies related to CRUD in our databases (MongoDB and Postgres). That is, it will provide standard methods so that, regardless of the strategy adopted, all data manipulation classes in the database are uniform. Thus, when using method B of strategy A, if it is not implemented, it will raise an exception, if it has an implementation, it should perform as expected.

2. Then we create the classes that will represent our **schemas**, which are the representation/configuration of an object in a database. For MongoDB we use Mongoose, and for Postgres we use Sequelize. These classes extend methods from the ICrud class

3. Then we create the classes that will compose our **strategy** for handling this data in the respective databases, which involves from connection to data manipulation procedures, considering a specific schema. These classes, which extend methods from the ICrud class, were named **MongoDB** and **Postgres**. They receive in their constructors two essential parameters: _the connection_ to be used (returned by a static method of the base class itself) and _the data schema_ that will be used

4. Next, we create our class that implements our connection context and data manipulation, called **ContextStrategy**. It receives in its constructor the parameter that will define the context that should be worked on. That is: it will contain the connection data that must be used and the data schema that will be manipulated

5. Finally, we create our contexts to be worked on and make them available for our routes

exemple:

```
const connMongo = await MongoDB.connect();
const contextMongo = new Context(new MongoDB(connMongo, HeroiSchema));

const connPG = await Postgres.connect();
const modelUsuario = await Postgres.defineModel(connPG, UsuarioSchema);
const contextPG = new Context(new Postgres(connPG, modelUsuario));
```

### Module 06 – Introduction to Postgres and Relational Databases

#### Lecture 08 - Multi DB - Postgres Implementation

We know a little about Sequelize and Postgres, a relational database

### Module 07 – Introduction to MongoBD and Non-Relational Databases

#### Class 09 - Multi DB - MongoDB Implementation

We know a little about MongoDB, a non-relational database

### Module 08 – Refactoring our project for multi-schema databases

#### Lecture 10 - Multi DB - Refactoring MongoDB implementation

#### Lecture 11 - Multi DB - Refactoring Postgres implementation

### Module 09 – Node.js and Web Services - Creating professional services with Hapi.js

In this module, classes 13 to 18, we created the Web Service routes that will be responsible for the CRUD of heroes.
for this we use the Hapi.js library

#### Lesson 12 - HTTP

#### Lesson 13 - Creating the API Structure

#### Lesson 14 - Listing API Heroes

#### Lesson 15 - Parameter Validation with Joi

#### Lesson 16 - Registering new Heroes in the API

#### Lecture 17 - Updating the Heroes registration in the API

#### Lecture 18 - Deleting Heroes from the API

### Module 10 – Service Documentation with Swagger

#### Lecture 19 - API Route Documentation with Swagger

This I consider the second "Boom" that hit my brain...
Seeing all the API documentation generated so richly and with so little effort was awesome!

#### Lecture 20 - Implementation of authentication strategy with JWT

In this class we learned how to implement a simple authentication validation and implement the control in all routes, to then define which routes will not require a valid token in the request header (ex: login)

#### Lecture 21 - User validation with the JWT token

Implementation of the token content validation strategy

### Module 12 – Publishing Services on the Web

In this module I saw about some practices for publishing services on the Web.
We use tools that have a free plan, such as Heroku (to host the service), PM2 (to monitor server indicators, in addition to implementing cluster services, and others). We also use the Istanbul library, which checks how well tested our API is, thus identifying sensitive points in the application.

- In this link you can check the documentation generated by Swagger: https://ilso-api-herois.herokuapp.com/documentation
- In this link you can check the API test coverage: https://ilso-api-herois.herokuapp.com/coverage/index.html

#### Lecture 22 - Environment variables (.env)

#### Lecture 23 - Publishing API with Heroku

#### Lecture 24 - Implementation of querying server indicators with PM2

#### Lecture 25 - Percentage of code coverage with tests
